<!DOCTYPE html>
<html>
<head>
  <title>d3dbsp Viewer (Rotatable Brushes)</title>
  <style>
    #dropzone {
      width: 200px;
      height: 100px;
      border: 2px dashed #ccc;
      text-align: center;
      line-height: 100px;
      margin: 10px;
    }
    #canvas {
      width: 640px;
      height: 480px;
      border: 1px solid #000;
    }
    table {
      border-collapse: collapse;
      margin: 10px;
    }
    th, td {
      border: 1px solid #ccc;
      padding: 5px;
    }
    .collapsible {
      cursor: pointer;
      background-color: #f1f1f1;
      padding: 10px;
      margin: 5px 0;
    }
    .content {
      display: none;
      padding: 10px;
    }
  </style>
</head>
<body>
  <div id="dropzone">Drop d3dbsp file here</div>
  <canvas id="canvas"></canvas>
  <div class="collapsible">Header</div>
  <div class="content">
    <table id="headerTable">
      <tr><th>Ident</th><td id="ident"></td></tr>
      <tr><th>Version</th><td id="version"></td></tr>
      <tr><th>Lumps</th><td><table id="lumpsTable"><tr><th>Index</th><th>Name</th><th>Length</th><th>Offset</th></tr></table></td></tr>
    </table>
  </div>
  <div class="collapsible">Materials (First 10)</div>
  <div class="content">
    <table id="materialsTable"><tr><th>Index</th><th>Material</th><th>Surface Flags</th><th>Content Flags</th></tr></table>
  </div>
  <div class="collapsible">Triangle Soups (First 10)</div>
  <div class="content">
    <table id="triangleSoupsTable"><tr><th>Index</th><th>Material Index</th><th>Lightmap Index</th><th>First Vertex</th><th>Vertex Count</th><th>Index Count</th><th>First Index</th></tr></table>
  </div>
  <div class="collapsible">Vertices (First 10)</div>
  <div class="content">
    <table id="verticesTable"><tr><th>Index</th><th>Position X</th><th>Position Y</th><th>Position Z</th><th>Normal X</th><th>Normal Y</th><th>Normal Z</th></tr></table>
  </div>
  <div class="collapsible">Draw Indexes (First 10)</div>
  <div class="content">
    <table id="drawIndexesTable"><tr><th>Index</th><th>Offset</th></tr></table>
  </div>
  <div class="collapsible">Brushes (First 10)</div>
  <div class="content">
    <table id="brushesTable"><tr><th>Index</th><th>Num Sides</th><th>Material Num</th></tr></table>
  </div>
  <div class="collapsible">Brush Sides (First 10)</div>
  <div class="content">
    <table id="brushSidesTable"><tr><th>Index</th><th>Plane</th><th>Material Num</th></tr></table>
  </div>
  <div class="collapsible">Planes (First 10)</div>
  <div class="content">
    <table id="planesTable"><tr><th>Index</th><th>Normal X</th><th>Normal Y</th><th>Normal Z</th><th>Distance</th></tr></table>
  </div>
  <div class="collapsible">Models (First 10)</div>
  <div class="content">
    <table id="modelsTable"><tr><th>Index</th><th>Mins X</th><th>Mins Y</th><th>Mins Z</th><th>Maxs X</th><th>Maxs Y</th><th>Maxs Z</th><th>First Triangle</th><th>Num Triangles</th></tr></table>
  </div>
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    class D3DBSPParser {
      constructor() {
        this.header = null;
        this.materials = [];
        this.triangleSoups = [];
        this.vertices = [];
        this.drawIndexes = null;
        this.brushes = [];
        this.brushSides = [];
        this.planes = [];
        this.models = [];
      }
      parse(buffer) {
        const view = new DataView(buffer);
        this.header = this.readHeader(view);
        this.materials = this.readMaterials(view);
        this.triangleSoups = this.readTriangleSoups(view);
        this.vertices = this.readVertices(view);
        this.drawIndexes = this.readDrawIndexes(view);
        this.brushes = this.readBrushes(view);
        this.brushSides = this.readBrushSides(view);
        this.planes = this.readPlanes(view);
        this.models = this.readModels(view);
      }
      readString(view, offset, length) {
        let str = '';
        for (let i = 0; i < length; i++) {
          const char = view.getUint8(offset + i);
          if (char === 0) break;
          str += String.fromCharCode(char);
        }
        return str;
      }
      readHeader(view) {
        const ident = this.readString(view, 0, 4);
        const version = view.getInt32(4, true);
        const lumps = [];
        for (let i = 0; i < 39; i++) { // LUMP_MAX from C file
          const base = 8 + i * 8;
          lumps.push({
            length: view.getInt32(base, true),
            offset: view.getInt32(base + 4, true),
            name: lumpNames[i] || `Unknown_${i}`
          });
        }
        return { ident, version, lumps };
      }
      readMaterials(view) {
        const lump = this.header.lumps[0]; // LUMP_MATERIALS
        const materials = [];
        const count = lump.length / 72; // sizeof(dmaterial_t)
        for (let i = 0; i < count; i++) {
          const base = lump.offset + i * 72;
          materials.push({
            material: this.readString(view, base, 64),
            surfaceFlags: view.getUint32(base + 64, true),
            contentFlags: view.getUint32(base + 68, true)
          });
        }
        return materials;
      }
      readTriangleSoups(view) {
        const lump = this.header.lumps[7]; // LUMP_TRIANGLES
        const count = lump.length / 16; // sizeof(DiskTriangleSoup)
        const triangleSoups = [];
        for (let i = 0; i < count; i++) {
          const base = lump.offset + i * 16;
          triangleSoups.push({
            materialIndex: view.getUint16(base, true),
            lightmapIndex: view.getUint16(base + 2, true),
            firstVertex: view.getUint32(base + 4, true),
            vertexCount: view.getUint16(base + 8, true),
            indexCount: view.getUint16(base + 10, true),
            firstIndex: view.getUint32(base + 12, true)
          });
        }
        return triangleSoups;
      }
      readVertices(view) {
        const lump = this.header.lumps[8]; // LUMP_DRAWVERTS
        const count = lump.length / 68; // sizeof(DiskGfxVertex)
        const vertices = [];
        for (let i = 0; i < count; i++) {
          const base = lump.offset + i * 68;
          vertices.push({
            position: [
              view.getFloat32(base, true),
              view.getFloat32(base + 4, true),
              view.getFloat32(base + 8, true)
            ],
            normal: [
              view.getFloat32(base + 12, true),
              view.getFloat32(base + 16, true),
              view.getFloat32(base + 20, true)
            ]
            // Additional fields like color, texCoord etc. could be added
          });
        }
        return vertices;
      }
      readDrawIndexes(view) {
        const lump = this.header.lumps[9]; // LUMP_DRAWINDICES
        return new Uint16Array(view.buffer, lump.offset, lump.length / 2);
      }
      readBrushes(view) {
        const lump = this.header.lumps[6]; // LUMP_BRUSHES
        const count = lump.length / 4; // sizeof(DiskBrush)
        const brushes = [];
        for (let i = 0; i < count; i++) {
          const base = lump.offset + i * 4;
          brushes.push({
            numSides: view.getUint16(base, true),
            materialNum: view.getUint16(base + 2, true)
          });
        }
        return brushes;
      }
      readBrushSides(view) {
        const lump = this.header.lumps[5]; // LUMP_BRUSHSIDES
        const count = lump.length / 8; // sizeof(cbrushside_t)
        const brushSides = [];
        for (let i = 0; i < count; i++) {
          const base = lump.offset + i * 8;
          brushSides.push({
            plane: view.getInt32(base, true),
            materialNum: view.getInt32(base + 4, true)
          });
        }
        return brushSides;
      }
      readPlanes(view) {
        const lump = this.header.lumps[4]; // LUMP_PLANES
        const count = lump.length / 16; // sizeof(DiskPlane)
        const planes = [];
        for (let i = 0; i < count; i++) {
          const base = lump.offset + i * 16;
          planes.push({
            normal: [
              view.getFloat32(base, true),
              view.getFloat32(base + 4, true),
              view.getFloat32(base + 8, true)
            ],
            dist: view.getFloat32(base + 12, true)
          });
        }
        return planes;
      }
      readModels(view) {
        const lump = this.header.lumps[35]; // LUMP_MODELS
        const count = lump.length / 48; // sizeof(dmodel_t)
        const models = [];
        for (let i = 0; i < count; i++) {
          const base = lump.offset + i * 48;
          models.push({
            mins: [
              view.getFloat32(base, true),
              view.getFloat32(base + 4, true),
              view.getFloat32(base + 8, true)
            ],
            maxs: [
              view.getFloat32(base + 12, true),
              view.getFloat32(base + 16, true),
              view.getFloat32(base + 20, true)
            ],
            firstTriangle: view.getUint32(base + 24, true),
            numTriangles: view.getUint32(base + 28, true)
            // Additional fields like firstSurface, numSurfaces etc. could be added
          });
        }
        return models;
      }
    }
    class Renderer {
      constructor(canvas) {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, 640 / 480, 0.1, 10000);
        this.renderer = new THREE.WebGLRenderer({ canvas });
        this.renderer.setSize(640, 480);
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.animate = this.animate.bind(this);
        this.animate();
      }
      animate() {
        requestAnimationFrame(this.animate);
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
      }
      renderModel(parser) {
        while (this.scene.children.length > 0) {
          this.scene.remove(this.scene.children[0]);
        }
        parser.triangleSoups.forEach((soup, index) => {
          const geometry = new THREE.BufferGeometry();
          const positions = new Float32Array(soup.vertexCount * 3);
          for (let i = 0; i < soup.vertexCount; i++) {
            const vertex = parser.vertices[soup.firstVertex + i];
            positions[i * 3] = vertex.position[0];
            positions[i * 3 + 1] = vertex.position[1];
            positions[i * 3 + 2] = vertex.position[2];
          }
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          const indices = parser.drawIndexes.slice(soup.firstIndex, soup.firstIndex + soup.indexCount);
          geometry.setIndex(new THREE.BufferAttribute(indices, 1));
          const color = new THREE.Color().setHSL(index / parser.triangleSoups.length, 1, 0.5);
          const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
          const mesh = new THREE.Mesh(geometry, material);
          this.scene.add(mesh);
        });
        this.adjustCamera(parser.vertices);
      }
      adjustCamera(vertices) {
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        vertices.forEach(vertex => {
          const pos = vertex.position;
          minX = Math.min(minX, pos[0]);
          minY = Math.min(minY, pos[1]);
          minZ = Math.min(minZ, pos[2]);
          maxX = Math.max(maxX, pos[0]);
          maxY = Math.max(maxY, pos[1]);
          maxZ = Math.max(maxZ, pos[2]);
        });
        const center = [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2];
        const size = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
        this.camera.position.set(center[0], center[1], center[2] + size);
        this.controls.target.set(center[0], center[1], center[2]);
        this.controls.update();
      }
      rotateBrushes(x, y, z) {
        const rotation = new THREE.Euler(x * Math.PI / 180, y * Math.PI / 180, z * Math.PI / 180);
        this.scene.children.forEach(mesh => {
          mesh.rotation.copy(rotation);
        });
      }
    }
    class D3DBSPViewer {
      constructor() {
        this.parser = new D3DBSPParser();
        this.renderer = new Renderer(document.getElementById('canvas'));
        this.dropzone = document.getElementById('dropzone');
        this.tables = {
          header: {
            ident: document.getElementById('ident'),
            version: document.getElementById('version'),
            lumps: document.getElementById('lumpsTable')
          },
          materials: document.getElementById('materialsTable'),
          triangleSoups: document.getElementById('triangleSoupsTable'),
          vertices: document.getElementById('verticesTable'),
          drawIndexes: document.getElementById('drawIndexesTable'),
          brushes: document.getElementById('brushesTable'),
          brushSides: document.getElementById('brushSidesTable'),
          planes: document.getElementById('planesTable'),
          models: document.getElementById('modelsTable')
        };
        this.setupEventListeners();
        this.setupCollapsibles();
      }
      setupEventListeners() {
        this.dropzone.addEventListener('dragover', e => e.preventDefault());
        this.dropzone.addEventListener('drop', e => {
          e.preventDefault();
          const file = e.dataTransfer.files[0];
          const reader = new FileReader();
          reader.onload = () => {
            this.parser.parse(reader.result);
            this.displayData();
            this.renderer.renderModel(this.parser);
            this.renderer.rotateBrushes(-90, 0, 90);
          };
          reader.readAsArrayBuffer(file);
        });
      }
      setupCollapsibles() {
        const collapsibles = document.getElementsByClassName('collapsible');
        for (let i = 0; i < collapsibles.length; i++) {
          collapsibles[i].addEventListener('click', function() {
            this.classList.toggle('active');
            const content = this.nextElementSibling;
            content.style.display = content.style.display === 'block' ? 'none' : 'block';
          });
        }
      }
      displayData() {
        this.displayHeader(this.parser.header);
        this.displayMaterials(this.parser.materials);
        this.displayTriangleSoups(this.parser.triangleSoups);
        this.displayVertices(this.parser.vertices);
        this.displayDrawIndexes(this.parser.drawIndexes);
        this.displayBrushes(this.parser.brushes);
        this.displayBrushSides(this.parser.brushSides);
        this.displayPlanes(this.parser.planes);
        this.displayModels(this.parser.models);
      }
      displayHeader(header) {
        this.tables.header.ident.textContent = header.ident;
        this.tables.header.version.textContent = header.version;
        while (this.tables.header.lumps.rows.length > 1) this.tables.header.lumps.deleteRow(1);
        header.lumps.forEach((lump, i) => {
          const row = this.tables.header.lumps.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = lump.name;
          row.insertCell().textContent = lump.length;
          row.insertCell().textContent = lump.offset;
        });
      }
      displayMaterials(materials) {
        while (this.tables.materials.rows.length > 1) this.tables.materials.deleteRow(1);
        materials.slice(0, 10).forEach((mat, i) => {
          const row = this.tables.materials.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = mat.material;
          row.insertCell().textContent = mat.surfaceFlags;
          row.insertCell().textContent = mat.contentFlags;
        });
      }
      displayTriangleSoups(triangleSoups) {
        while (this.tables.triangleSoups.rows.length > 1) this.tables.triangleSoups.deleteRow(1);
        triangleSoups.slice(0, 10).forEach((soup, i) => {
          const row = this.tables.triangleSoups.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = soup.materialIndex;
          row.insertCell().textContent = soup.lightmapIndex;
          row.insertCell().textContent = soup.firstVertex;
          row.insertCell().textContent = soup.vertexCount;
          row.insertCell().textContent = soup.indexCount;
          row.insertCell().textContent = soup.firstIndex;
        });
      }
      displayVertices(vertices) {
        while (this.tables.vertices.rows.length > 1) this.tables.vertices.deleteRow(1);
        vertices.slice(0, 10).forEach((vertex, i) => {
          const row = this.tables.vertices.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = vertex.position[0].toFixed(2);
          row.insertCell().textContent = vertex.position[1].toFixed(2);
          row.insertCell().textContent = vertex.position[2].toFixed(2);
          row.insertCell().textContent = vertex.normal[0].toFixed(2);
          row.insertCell().textContent = vertex.normal[1].toFixed(2);
          row.insertCell().textContent = vertex.normal[2].toFixed(2);
        });
      }
      displayDrawIndexes(drawIndexes) {
        while (this.tables.drawIndexes.rows.length > 1) this.tables.drawIndexes.deleteRow(1);
        drawIndexes.slice(0, 10).forEach((offset, i) => {
          const row = this.tables.drawIndexes.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = offset;
        });
      }
      displayBrushes(brushes) {
        while (this.tables.brushes.rows.length > 1) this.tables.brushes.deleteRow(1);
        brushes.slice(0, 10).forEach((brush, i) => {
          const row = this.tables.brushes.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = brush.numSides;
          row.insertCell().textContent = brush.materialNum;
        });
      }
      displayBrushSides(brushSides) {
        while (this.tables.brushSides.rows.length > 1) this.tables.brushSides.deleteRow(1);
        brushSides.slice(0, 10).forEach((side, i) => {
          const row = this.tables.brushSides.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = side.plane;
          row.insertCell().textContent = side.materialNum;
        });
      }
      displayPlanes(planes) {
        while (this.tables.planes.rows.length > 1) this.tables.planes.deleteRow(1);
        planes.slice(0, 10).forEach((plane, i) => {
          const row = this.tables.planes.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = plane.normal[0].toFixed(2);
          row.insertCell().textContent = plane.normal[1].toFixed(2);
          row.insertCell().textContent = plane.normal[2].toFixed(2);
          row.insertCell().textContent = plane.dist.toFixed(2);
        });
      }
      displayModels(models) {
        while (this.tables.models.rows.length > 1) this.tables.models.deleteRow(1);
        models.slice(0, 10).forEach((model, i) => {
          const row = this.tables.models.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = model.mins[0].toFixed(2);
          row.insertCell().textContent = model.mins[1].toFixed(2);
          row.insertCell().textContent = model.mins[2].toFixed(2);
          row.insertCell().textContent = model.maxs[0].toFixed(2);
          row.insertCell().textContent = model.maxs[1].toFixed(2);
          row.insertCell().textContent = model.maxs[2].toFixed(2);
          row.insertCell().textContent = model.firstTriangle;
          row.insertCell().textContent = model.numTriangles;
        });
      }
    }
    const lumpNames = [
      "materials", "lightmaps", "light grid hash", "light grid values", "planes",
      "brushsides", "brushes", "trianglesoups", "drawverts", "drawindexes",
      "cullgroups", "cullgroupindexes", "shadowverts", "shadowindices",
      "shadowclusters", "shadowaabbtrees", "shadowsources", "portalverts",
      "occluders", "occluderplanes", "occluderedges", "occluderindexes",
      "aabbtrees", "cells", "portals", "nodes", "leafs", "leafbrushes",
      "leafsurfaces", "collisionverts", "collisionedges", "collisiontris",
      "collisionborders", "collisionparts", "collisionaabbs", "models",
      "visibility", "entdata", "paths"
    ];
    const viewer = new D3DBSPViewer();
    window.viewer = viewer;
  </script>
</body>
</html>
