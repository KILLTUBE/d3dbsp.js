<!DOCTYPE html>
<html>
<head>
  <title>d3dbsp Viewer (Parser Free from HTML)</title>
  <style>
    #dropzone {
      width: 200px;
      height: 100px;
      border: 2px dashed #ccc;
      text-align: center;
      line-height: 100px;
      margin: 10px;
    }
    #canvas {
      width: 640px;
      height: 480px;
      border: 1px solid #000;
    }
    table {
      border-collapse: collapse;
      margin: 10px;
    }
    th,
    td {
      border: 1px solid #ccc;
      padding: 5px;
    }
  </style>
</head>
<body>
  <div id="dropzone">Drop d3dbsp file here</div>
  <canvas id="canvas"></canvas>
  <h2>Header</h2>
  <table id="headerTable">
    <tr>
      <th>Ident</th>
      <td id="ident"></td>
    </tr>
    <tr>
      <th>Version</th>
      <td id="version"></td>
    </tr>
    <tr>
      <th>Lumps</th>
      <td>
        <table id="lumpsTable">
          <tr>
            <th>Index</th>
            <th>Length</th>
            <th>Offset</th>
          </tr>
        </table>
      </td>
    </tr>
  </table>
  <h2>Triangle Soups (First 10)</h2>
  <table id="triangleSoupsTable">
    <tr>
      <th>Index</th>
      <th>bla</th>
      <th>foo</th>
      <th>vertexFirst</th>
      <th>nVertex</th>
      <th>nTriangles</th>
      <th>triangleFirst</th>
    </tr>
  </table>
  <h2>Vertices (First 10)</h2>
  <table id="verticesTable">
    <tr>
      <th>Index</th>
      <th>Position X</th>
      <th>Position Y</th>
      <th>Position Z</th>
    </tr>
  </table>
  <h2>Draw Indexes (First 10)</h2>
  <table id="drawIndexesTable">
    <tr>
      <th>Index</th>
      <th>Offset</th>
    </tr>
  </table>
  <!-- Three.js and OrbitControls from CDN -->
  <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script>
    // Class to parse d3dbsp files, free from HTML concerns
    class D3DBSPParser {
      constructor() {
        this.header = null;
        this.triangleSoups = [];
        this.vertices = [];
        this.drawIndexes = null;
      }
      parse(buffer) {
        const view = new DataView(buffer);
        this.header = this.readHeader(view);
        this.triangleSoups = this.readTriangleSoups(view, this.header.lumps[7]);
        this.vertices = this.readVertices(view, this.header.lumps[8]);
        this.drawIndexes = this.readDrawIndexes(view, this.header.lumps[9]);
      }
      readString(view, offset, length) {
        let str = '';
        for (let i = 0; i < length; i++) {
          str += String.fromCharCode(view.getUint8(offset + i));
        }
        return str;
      }
      readHeader(view) {
        const ident = this.readString(view, 0, 4);
        const version = view.getInt32(4, true);
        const lumps = [];
        for (let i = 0; i < 100; i++) {
          const base = 8 + i * 8;
          lumps.push({
            length: view.getInt32(base, true),
            offset: view.getInt32(base + 4, true)
          });
        }
        return { ident, version, lumps };
      }
      readTriangleSoups(view, lump) {
        const nTriangleSoups = lump.length / 16;
        const triangleSoups = [];
        for (let i = 0; i < nTriangleSoups; i++) {
          const base = lump.offset + i * 16;
          triangleSoups.push({
            bla: view.getUint16(base, true),
            foo: view.getUint16(base + 2, true),
            vertexFirst: view.getUint32(base + 4, true),
            nVertex: view.getUint16(base + 8, true),
            nTriangles: view.getUint16(base + 10, true),
            triangleFirst: view.getUint32(base + 12, true)
          });
        }
        return triangleSoups;
      }
      readVertices(view, lump) {
        const nVertices = lump.length / 68;
        const vertices = [];
        for (let i = 0; i < nVertices; i++) {
          const base = lump.offset + i * 68;
          vertices.push({
            position: [
              view.getFloat32(base, true),
              view.getFloat32(base + 4, true),
              view.getFloat32(base + 8, true)
            ]
          });
        }
        return vertices;
      }
      readDrawIndexes(view, lump) {
        return new Uint16Array(view.buffer, lump.offset, lump.length / 2);
      }
    }
    // Class to handle Three.js rendering
    class Renderer {
      constructor(canvas) {
        this.scene = new THREE.Scene();
        this.camera = new THREE.PerspectiveCamera(75, 640 / 480, 0.1, 10000);
        this.renderer = new THREE.WebGLRenderer({ canvas });
        this.renderer.setSize(640, 480);
        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.enableDamping = true;
        this.controls.dampingFactor = 0.05;
        this.animate = this.animate.bind(this);
        this.animate();
      }
      animate() {
        requestAnimationFrame(this.animate);
        this.controls.update();
        this.renderer.render(this.scene, this.camera);
      }
      renderModel(parser) {
        while (this.scene.children.length > 0) {
          this.scene.remove(this.scene.children[0]);
        }
        parser.triangleSoups.forEach((soup, index) => {
          const geometry = new THREE.BufferGeometry();
          const positions = new Float32Array(soup.nVertex * 3);
          for (let i = 0; i < soup.nVertex; i++) {
            const vertex = parser.vertices[soup.vertexFirst + i];
            positions[i * 3] = vertex.position[0];
            positions[i * 3 + 1] = vertex.position[1];
            positions[i * 3 + 2] = vertex.position[2];
          }
          geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
          const indices = parser.drawIndexes.slice(soup.triangleFirst, soup.triangleFirst + soup.nTriangles);
          geometry.setIndex(new THREE.BufferAttribute(indices, 1));
          const color = new THREE.Color().setHSL(index / parser.triangleSoups.length, 1, 0.5);
          const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });
          const mesh = new THREE.Mesh(geometry, material);
          this.scene.add(mesh);
        });
        this.adjustCamera(parser.vertices);
      }
      adjustCamera(vertices) {
        let minX = Infinity, minY = Infinity, minZ = Infinity;
        let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
        vertices.forEach(vertex => {
          const pos = vertex.position;
          minX = Math.min(minX, pos[0]);
          minY = Math.min(minY, pos[1]);
          minZ = Math.min(minZ, pos[2]);
          maxX = Math.max(maxX, pos[0]);
          maxY = Math.max(maxY, pos[1]);
          maxZ = Math.max(maxZ, pos[2]);
        });
        const center = [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2];
        const size = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
        this.camera.position.set(center[0], center[1], center[2] + size);
        this.controls.target.set(center[0], center[1], center[2]);
        this.controls.update();
      }
    }
    // Main viewer class to orchestrate parsing, rendering, and HTML display
    class D3DBSPViewer {
      constructor() {
        this.parser = new D3DBSPParser();
        this.renderer = new Renderer(document.getElementById('canvas'));
        this.dropzone = document.getElementById('dropzone');
        this.headerTable = {
          ident: document.getElementById('ident'),
          version: document.getElementById('version'),
          lumps: document.getElementById('lumpsTable')
        };
        this.triangleSoupsTable = document.getElementById('triangleSoupsTable');
        this.verticesTable = document.getElementById('verticesTable');
        this.drawIndexesTable = document.getElementById('drawIndexesTable');
        this.handleDragOver = this.handleDragOver.bind(this);
        this.handleDrop = this.handleDrop.bind(this);
        this.setupEventListeners();
      }
      setupEventListeners() {
        this.dropzone.addEventListener('dragover', this.handleDragOver);
        this.dropzone.addEventListener('drop', this.handleDrop);
      }
      handleDragOver(e) {
        e.preventDefault();
      }
      handleDrop(e) {
        e.preventDefault();
        const file = e.dataTransfer.files[0];
        const reader = new FileReader();
        reader.onload = () => {
          this.parser.parse(reader.result);
          this.displayData();
          this.renderer.renderModel(this.parser);
        };
        reader.readAsArrayBuffer(file);
      }
      displayData() {
        this.displayHeader(this.parser.header);
        this.displayTriangleSoups(this.parser.triangleSoups);
        this.displayVertices(this.parser.vertices);
        this.displayDrawIndexes(this.parser.drawIndexes);
      }
      displayHeader(header) {
        this.headerTable.ident.textContent = header.ident;
        this.headerTable.version.textContent = header.version;
        while (this.headerTable.lumps.rows.length > 1) this.headerTable.lumps.deleteRow(1);
        header.lumps.forEach((lump, i) => {
          const row = this.headerTable.lumps.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = lump.length;
          row.insertCell().textContent = lump.offset;
        });
      }
      displayTriangleSoups(triangleSoups) {
        while (this.triangleSoupsTable.rows.length > 1) this.triangleSoupsTable.deleteRow(1);
        triangleSoups.slice(0, 10).forEach((soup, i) => {
          const row = this.triangleSoupsTable.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = soup.bla;
          row.insertCell().textContent = soup.foo;
          row.insertCell().textContent = soup.vertexFirst;
          row.insertCell().textContent = soup.nVertex;
          row.insertCell().textContent = soup.nTriangles;
          row.insertCell().textContent = soup.triangleFirst;
        });
      }
      displayVertices(vertices) {
        while (this.verticesTable.rows.length > 1) this.verticesTable.deleteRow(1);
        vertices.slice(0, 10).forEach((vertex, i) => {
          const row = this.verticesTable.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = vertex.position[0].toFixed(2);
          row.insertCell().textContent = vertex.position[1].toFixed(2);
          row.insertCell().textContent = vertex.position[2].toFixed(2);
        });
      }
      displayDrawIndexes(drawIndexes) {
        while (this.drawIndexesTable.rows.length > 1) this.drawIndexesTable.deleteRow(1);
        drawIndexes.slice(0, 10).forEach((offset, i) => {
          const row = this.drawIndexesTable.insertRow();
          row.insertCell().textContent = i;
          row.insertCell().textContent = offset;
        });
      }
    }
    // Instantiate the viewer
    const viewer = new D3DBSPViewer();
    window.viewer = viewer; // Expose viewer to global scope for debugging
  </script>
</body>
</html>
