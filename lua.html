<!DOCTYPE html>
<html>
<head>
    <title>d3dbsp Viewer</title>
    <style>
        #dropzone {
            width: 200px;
            height: 100px;
            border: 2px dashed #ccc;
            text-align: center;
            line-height: 100px;
            margin: 10px;
        }
        #canvas {
            width: 640px;
            height: 480px;
            border: 1px solid #000;
        }
        table {
            border-collapse: collapse;
            margin: 10px;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 5px;
        }
    </style>
</head>
<body>
    <div id="dropzone">Drop d3dbsp file here</div>
    <canvas id="canvas"></canvas>

    <h2>Header</h2>
    <table id="headerTable">
        <tr><th>Ident</th><td id="ident"></td></tr>
        <tr><th>Version</th><td id="version"></td></tr>
        <tr><th>Lumps</th><td><table id="lumpsTable"><tr><th>Index</th><th>Length</th><th>Offset</th></tr></table></td></tr>
    </table>

    <h2>Triangle Soups (First 10)</h2>
    <table id="triangleSoupsTable">
        <tr><th>Index</th><th>bla</th><th>foo</th><th>vertexFirst</th><th>nVertex</th><th>nTriangles</th><th>triangleFirst</th></tr>
    </table>

    <h2>Vertices (First 10)</h2>
    <table id="verticesTable">
        <tr><th>Index</th><th>Position X</th><th>Position Y</th><th>Position Z</th></tr>
    </table>

    <h2>Draw Indexes (First 10)</h2>
    <table id="drawIndexesTable">
        <tr><th>Index</th><th>Offset</th></tr>
    </table>

    <!-- Three.js and OrbitControls from CDN -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Three.js setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, 640 / 480, 0.1, 10000);
        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas') });
        renderer.setSize(640, 480);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Drag and drop handling
        const dropzone = document.getElementById('dropzone');
        dropzone.addEventListener('dragover', (e) => e.preventDefault());
        dropzone.addEventListener('drop', (e) => {
            e.preventDefault();
            const file = e.dataTransfer.files[0];
            const reader = new FileReader();
            reader.onload = () => parseAndRender(reader.result);
            reader.readAsArrayBuffer(file);
        });

        // Parse and render the d3dbsp file
        function parseAndRender(buffer) {
            const view = new DataView(buffer);

            // Parse header
            const header = readHeader(view);
            displayHeader(header);

            // Parse lumps (assuming indices from LuaJIT: 7=triangleSoups, 8=vertices, 9=drawIndexes)
            const triangleSoups = readTriangleSoups(view, header.lumps[7]);
            const vertices = readVertices(view, header.lumps[8]);
            const drawIndexes = readDrawIndexes(view, header.lumps[9]);

            // Display parsed data for debugging
            displayTriangleSoups(triangleSoups);
            displayVertices(vertices);
            displayDrawIndexes(drawIndexes);

            // Clear previous scene content
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }

            // Render each triangle soup
            triangleSoups.forEach((soup, index) => {
                const geometry = new THREE.BufferGeometry();

                // Set vertex positions
                const positions = new Float32Array(soup.nVertex * 3);
                for (let i = 0; i < soup.nVertex; i++) {
                    const vertex = vertices[soup.vertexFirst + i];
                    positions[i * 3] = vertex.position[0];
                    positions[i * 3 + 1] = vertex.position[1];
                    positions[i * 3 + 2] = vertex.position[2];
                }
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

                // Set indices
                const indices = drawIndexes.slice(soup.triangleFirst, soup.triangleFirst + soup.nTriangles);
                geometry.setIndex(new THREE.BufferAttribute(indices, 1));

                // Create material with a unique color per soup
                const color = new THREE.Color().setHSL(index / triangleSoups.length, 1, 0.5);
                const material = new THREE.MeshBasicMaterial({ color: color, side: THREE.DoubleSide });

                // Create and add mesh
                const mesh = new THREE.Mesh(geometry, material);
                scene.add(mesh);
            });

            // Adjust camera based on bounding box
            adjustCamera(vertices);
        }

        // Helper function to read a string from DataView
        function readString(view, offset, length) {
            let str = '';
            for (let i = 0; i < length; i++) {
                str += String.fromCharCode(view.getUint8(offset + i));
            }
            return str;
        }

        // Parse the header
        function readHeader(view) {
            const ident = readString(view, 0, 4);
            const version = view.getInt32(4, true); // Little-endian
            const lumps = [];
            for (let i = 0; i < 100; i++) {
                const base = 8 + i * 8;
                lumps.push({
                    length: view.getInt32(base, true),
                    offset: view.getInt32(base + 4, true)
                });
            }
            return { ident, version, lumps };
        }

        // Parse triangle soups (16 bytes each)
        function readTriangleSoups(view, lump) {
            const nTriangleSoups = lump.length / 16;
            const triangleSoups = [];
            for (let i = 0; i < nTriangleSoups; i++) {
                const base = lump.offset + i * 16;
                triangleSoups.push({
                    bla: view.getUint16(base, true),
                    foo: view.getUint16(base + 2, true),
                    vertexFirst: view.getUint32(base + 4, true),
                    nVertex: view.getUint16(base + 8, true),
                    nTriangles: view.getUint16(base + 10, true),
                    triangleFirst: view.getUint32(base + 12, true)
                });
            }
            return triangleSoups;
        }

        // Parse vertices (68 bytes each, only using position)
        function readVertices(view, lump) {
            const nVertices = lump.length / 68;
            const vertices = [];
            for (let i = 0; i < nVertices; i++) {
                const base = lump.offset + i * 68;
                vertices.push({
                    position: [
                        view.getFloat32(base, true),
                        view.getFloat32(base + 4, true),
                        view.getFloat32(base + 8, true)
                    ]
                });
            }
            return vertices;
        }

        // Parse draw indexes (2 bytes each)
        function readDrawIndexes(view, lump) {
            return new Uint16Array(view.buffer, lump.offset, lump.length / 2);
        }

        // Display header data
        function displayHeader(header) {
            document.getElementById('ident').textContent = header.ident;
            document.getElementById('version').textContent = header.version;
            const lumpsTable = document.getElementById('lumpsTable');
            while (lumpsTable.rows.length > 1) lumpsTable.deleteRow(1);
            header.lumps.forEach((lump, i) => {
                const row = lumpsTable.insertRow();
                row.insertCell().textContent = i;
                row.insertCell().textContent = lump.length;
                row.insertCell().textContent = lump.offset;
            });
        }

        // Display triangle soups (first 10)
        function displayTriangleSoups(triangleSoups) {
            const table = document.getElementById('triangleSoupsTable');
            while (table.rows.length > 1) table.deleteRow(1);
            triangleSoups.slice(0, 10).forEach((soup, i) => {
                const row = table.insertRow();
                row.insertCell().textContent = i;
                row.insertCell().textContent = soup.bla;
                row.insertCell().textContent = soup.foo;
                row.insertCell().textContent = soup.vertexFirst;
                row.insertCell().textContent = soup.nVertex;
                row.insertCell().textContent = soup.nTriangles;
                row.insertCell().textContent = soup.triangleFirst;
            });
        }

        // Display vertices (first 10)
        function displayVertices(vertices) {
            const table = document.getElementById('verticesTable');
            while (table.rows.length > 1) table.deleteRow(1);
            vertices.slice(0, 10).forEach((vertex, i) => {
                const row = table.insertRow();
                row.insertCell().textContent = i;
                row.insertCell().textContent = vertex.position[0].toFixed(2);
                row.insertCell().textContent = vertex.position[1].toFixed(2);
                row.insertCell().textContent = vertex.position[2].toFixed(2);
            });
        }

        // Display draw indexes (first 10)
        function displayDrawIndexes(drawIndexes) {
            const table = document.getElementById('drawIndexesTable');
            while (table.rows.length > 1) table.deleteRow(1);
            drawIndexes.slice(0, 10).forEach((offset, i) => {
                const row = table.insertRow();
                row.insertCell().textContent = i;
                row.insertCell().textContent = offset;
            });
        }

        // Adjust camera based on model bounds
        function adjustCamera(vertices) {
            let minX = Infinity, minY = Infinity, minZ = Infinity;
            let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;
            vertices.forEach(vertex => {
                const pos = vertex.position;
                minX = Math.min(minX, pos[0]);
                minY = Math.min(minY, pos[1]);
                minZ = Math.min(minZ, pos[2]);
                maxX = Math.max(maxX, pos[0]);
                maxY = Math.max(maxY, pos[1]);
                maxZ = Math.max(maxZ, pos[2]);
            });
            const center = [(minX + maxX) / 2, (minY + maxY) / 2, (minZ + maxZ) / 2];
            const size = Math.max(maxX - minX, maxY - minY, maxZ - minZ);
            camera.position.set(center[0], center[1], center[2] + size);
            controls.target.set(center[0], center[1], center[2]);
            controls.update();
        }
    </script>
</body>
</html>
